#ifndef CURRENT_SENSOR
#define CURRENT_SENSOR

#include <CoapSensor.h>

#define NUMBER_OF_SAMPLES 1480
#define ICAL 30

long readVcc() {
  long result;

  #if defined(__AVR_ATmega168__) || defined(__AVR_ATmega328__) || defined (__AVR_ATmega328P__)
  ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);  
  #elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
  ADMUX = _BV(REFS0) | _BV(MUX4) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
  ADCSRB &= ~_BV(MUX5);   // Without this the function always returns -1 on the ATmega2560 http://openenergymonitor.org/emon/node/2253#comment-11432
  #elif defined (__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
  ADMUX = _BV(MUX5) | _BV(MUX0);
  #elif defined (__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
  ADMUX = _BV(MUX3) | _BV(MUX2);
	
  #endif

#if defined(__AVR__) 
  delay(2);					// Wait for Vref to settle
  ADCSRA |= _BV(ADSC);				// Convert
  while (bit_is_set(ADCSRA,ADSC));
  result = ADCL;
  result |= ADCH<<8;
  result = 1126400L / result;			//1100mV*1024 ADC steps http://openenergymonitor.org/emon/node/1186
  return result;
#elif defined(__arm__)
  return (3.3);				       //Arduino Due
#else return (3.3);                            //Wild gess that other un-supported architectures will be running a 3.3V!
#endif
}
/*
double calcIrms(int inPinI){
 
  //Set Voltage and current input pins

    //Calibration coeficients
    //These need to be set in order to obtain accurate results
    
    //--------------------------------------------------------------------------------------
    // Variable declaration for emon_calc procedure
    //--------------------------------------------------------------------------------------
 int lastSampleI,sampleI;                      
  double lastFilteredI=0.0;
double filteredI=0.0;                  
  double sqI=0.0;
//double offsetI=512.0;
//Reset accumulators
  double sumI=0.0;


double SUPPLYVOLTAGE =readVcc();

  
  for (int n = 0; n < NUMBER_OF_SAMPLES; n++)
  {
    lastSampleI = sampleI;
    sampleI = analogRead(inPinI);
    lastFilteredI = filteredI;
    filteredI = 0.996*(lastFilteredI+sampleI-lastSampleI);

    // Root-mean-square method current
    // 1) square current values
    sqI = filteredI * filteredI;
    // 2) sum 
    sumI += sqI;
  }

  double I_RATIO = ICAL *((SUPPLYVOLTAGE/1000.0) / 1023.0);
 double Irms = I_RATIO * sqrt(sumI / NUMBER_OF_SAMPLES); 

  //Reset accumulators
  sumI = 0;
//--------------------------------------------------------------------------------------       
// return sampleI;
  return Irms;

}*/
/*
int calcIrms(int inPinI)
{
int pin=inPinI;
 double SUPPLYVOLTAGE =5000.0;
//int SUPPLYVOLTAGE =readVcc();
 double lastFilteredI=0.0;
double filteredI=0.0;                  
  double sqI=0.0;
  double sumI=0.0;
  int lastSampleI=0;
int sampleI=0;
  for (int n = 0; n < 148; n++)
  {
    lastSampleI = sampleI;
    sampleI = analogRead(pin);
    lastFilteredI = filteredI;
    filteredI = 0.996*(lastFilteredI+sampleI-lastSampleI);

    // Root-mean-square method current
    // 1) square current values
    sqI = filteredI * filteredI;
    // 2) sum 
    sumI += sqI;
  }

  double I_RATIO = 30 *((SUPPLYVOLTAGE/1000.0) / 1023.0);
  int Irms =(int) ((I_RATIO * sqrt(sumI / 148))*1000); 

  //Reset accumulators
  //sumI = 0;
//--------------------------------------------------------------------------------------       
 //return sampleI;
  return Irms;
}*/
class CurrentSensor: 
public CoapSensor 
{
public:
  int status;
 unsigned long timestamp;
 int lastSampleI,sampleI;                      
  double lastFilteredI;
double filteredI;                  
  double sqI;
//Reset accumulators
  double sumI;
double SUPPLYVOLTAGE;

  
  CurrentSensor (char * name,int pin): 
  CoapSensor(name)
  {   
	this->pin=pin; 
    timestamp = 0;
    this->status=0;
    this->set_notify_time(30);
	this->sampleI=0;
	this->filteredI=0.0;
  }

  void get_value( uint8_t* output_data, size_t* output_data_len)
  {
    *output_data_len = sprintf( (char*)output_data, "%d", this->status); 
  }

  void check(void)
  {
    if(millis() - timestamp > 5000)
    {
     
      //this->status = (int)(calcIrms(this->pin)*1000);  // Calculate Irms only
   // if (this->status<115){
	//this->status=0;
     //} 
	SUPPLYVOLTAGE =readVcc();

  
	  for (int n = 0; n < NUMBER_OF_SAMPLES; n++)
	  {
	    lastSampleI = sampleI;
	    sampleI = analogRead(this->pin);
	    lastFilteredI = filteredI;
	    filteredI = 0.996*(lastFilteredI+sampleI-lastSampleI);

	    // Root-mean-square method current
	    // 1) square current values
	    sqI = filteredI * filteredI;
	    // 2) sum 
	    sumI += sqI;
	  }

	  double I_RATIO = ICAL *((SUPPLYVOLTAGE/1000.0) / 1023.0);
	 double Irms = I_RATIO * sqrt(sumI / NUMBER_OF_SAMPLES); 

	  //Reset accumulators
	  sumI = 0;
	//--------------------------------------------------------------------------------------       
	// return sampleI;
	//  return Irms;
	this->status=(int)(Irms*1000);
	
	timestamp = millis();
    }
  }



	
};
#endif
