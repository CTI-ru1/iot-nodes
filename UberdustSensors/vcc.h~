#ifndef VCC_SENSOR
#define VCC_SENSOR

#include <CoapSensor.h>


long readVcc() {
  long result;
  
  //not used on emonTx V3 - as Vcc is always 3.3V - eliminates bandgap error and need for calibration http://harizanov.com/2013/09/thoughts-on-avr-adc-accuracy/

  #if defined(__AVR_ATmega168__) || defined(__AVR_ATmega328__) || defined (__AVR_ATmega328P__)
  ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);  
  #elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
  ADMUX = _BV(REFS0) | _BV(MUX4) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
  ADCSRB &= ~_BV(MUX5);   // Without this the function always returns -1 on the ATmega2560 http://openenergymonitor.org/emon/node/2253#comment-11432
  #elif defined (__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
  ADMUX = _BV(MUX5) | _BV(MUX0);
  #elif defined (__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
  ADMUX = _BV(MUX3) | _BV(MUX2);
	
  #endif


  #if defined(__AVR__) 
  delay(2);                                        // Wait for Vref to settle
  ADCSRA |= _BV(ADSC);                             // Convert
  while (bit_is_set(ADCSRA,ADSC));
  result = ADCL;
  result |= ADCH<<8;
  result = 1126400L / result;                     //1100mV*1024 ADC steps http://openenergymonitor.org/emon/node/1186
  return result;
 #elif defined(__arm__)
  return (3300);                                  //Arduino Due
 #else 
  return (3300);                                  //Guess that other un-supported architectures will be running a 3.3V!
 #endif
}


class vcc: 
public CoapSensor 
{
public:
  int status;
  unsigned long timestamp;
  vcc (char * name): 
  CoapSensor(name)
  {    
    timestamp = 0;
  //  calcIrms();  // Calculate Irms only
    this->status=0;
    this->set_notify_time(30);
  }
  
 // CurrentSensor (char * name,int pin): 
  //CoapSensor(name)
  //{    
   // current(pin);
  //  calcIrms();
   // timestamp = 0;
   // calcIrms();  // Calculate Irms only
    //this->status=0;
    //this->set_notify_time(30);
  //}

  void get_value( uint8_t* output_data, size_t* output_data_len)
  {
    *output_data_len = sprintf( (char*)output_data, "%d", this->status); 
  }

  void check(void)
  {
    if(millis() - timestamp > 5000)
    {
      timestamp = millis();
      this->status = readVcc();  // Calculate Irms only
      if (this->status<100){
	this->status=0;
      }
    }
  }
/*
  int current(){
    return this->status;
  }
  
  void current(int _inPinI){
   inPinI = _inPinI;
}*/
/*
double calcIrms(){
    //Reset accumulators
  sumI = 0;

   #if defined emonTxV3
	int SUPPLYVOLTAGE=3300;
   #else 
	int SUPPLYVOLTAGE = readVcc();
   #endif
//int SUPPLYVOLTAGE = 5000;
  
  for (int n = 0; n < NUMBER_OF_SAMPLES; n++)
  {
    lastSampleI = sampleI;
    sampleI = analogRead(inPinI);
    lastFilteredI = filteredI;
    filteredI = 0.996*(lastFilteredI+sampleI-lastSampleI);

    // Root-mean-square method current
    // 1) square current values
    sqI = filteredI * filteredI;
    // 2) sum 
    sumI += sqI;
  }

//--------------------------------------------------------------------------------------       
 return(sumI);
 // return  (ICAL *((SUPPLYVOLTAGE) / 1023.0))* sqrt(sumI / NUMBER_OF_SAMPLES);
}


private :
  //Set Voltage and current input pins
    int inPinI;
    //Calibration coeficients
    //These need to be set in order to obtain accurate results
    
    //--------------------------------------------------------------------------------------
    // Variable declaration for emon_calc procedure
    //--------------------------------------------------------------------------------------
	int lastSampleI,sampleI;                      
	double lastFilteredI, filteredI;                  
	double sqI;
//Reset accumulators
  long sumI;
	*/
};
#endif
